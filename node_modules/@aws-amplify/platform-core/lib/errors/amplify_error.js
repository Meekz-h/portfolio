"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AmplifyError = void 0;
const _1 = require(".");
/**
 * Base class for all Amplify errors or faults
 */
class AmplifyError extends Error {
    name;
    classification;
    options;
    cause;
    serializedError;
    message;
    resolution;
    details;
    link;
    code;
    /**
     * You should use AmplifyUserError or AmplifyLibraryFault to throw an error.
     * @param name - a user friendly name for the exception
     * @param classification - LibraryFault or UserError
     * @param options - error stack, resolution steps, details, or help links
     * @param cause If you are throwing this exception from within a catch block,
     * you must provide the exception that was caught.
     * @example
     * try {
     *  ...
     * } catch (error){
     *    throw new AmplifyError(...,...,error);
     * }
     */
    constructor(name, classification, options, cause) {
        // If an AmplifyError was already thrown, we must allow it to reach the user.
        // This ensures that resolution steps, and the original error are bubbled up.
        super(options.message, { cause });
        this.name = name;
        this.classification = classification;
        this.options = options;
        this.cause = cause;
        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(this, AmplifyError.prototype);
        this.message = options.message;
        this.details = options.details;
        this.resolution = options.resolution;
        this.code = options.code;
        this.link = options.link;
        if (cause && cause instanceof AmplifyError) {
            cause.serializedError = undefined;
        }
        this.serializedError = JSON.stringify({
            name,
            classification,
            options,
            cause,
        });
    }
    static fromStderr = (_stderr) => {
        const extractionRegex = /["']?serializedError["']?:[ ]?["'](.*)["']/;
        const serialized = _stderr.match(extractionRegex);
        if (serialized && serialized.length == 2) {
            try {
                const { name, classification, options, cause } = JSON.parse(serialized[1]);
                return classification === 'ERROR'
                    ? new _1.AmplifyUserError(name, options, cause)
                    : new _1.AmplifyFault(name, options, cause);
            }
            catch (error) {
                // cannot deserialize
            }
        }
        return undefined;
    };
    static fromError = (error) => {
        const errorMessage = error instanceof Error
            ? `${error.name}: ${error.message}`
            : 'An unknown error happened. Check downstream error';
        return new _1.AmplifyFault('UnknownFault', {
            message: errorMessage,
        }, error instanceof Error ? error : new Error(String(error)));
    };
}
exports.AmplifyError = AmplifyError;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW1wbGlmeV9lcnJvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lcnJvcnMvYW1wbGlmeV9lcnJvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSx3QkFBbUQ7QUFFbkQ7O0dBRUc7QUFDSCxNQUFzQixZQUFhLFNBQVEsS0FBSztJQXVCNUI7SUFDQTtJQUNDO0lBQ0Q7SUF6QlgsZUFBZSxDQUFVO0lBQ2hCLE9BQU8sQ0FBUztJQUNoQixVQUFVLENBQVU7SUFDcEIsT0FBTyxDQUFVO0lBQ2pCLElBQUksQ0FBVTtJQUNkLElBQUksQ0FBVTtJQUU5Qjs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0gsWUFDa0IsSUFBc0IsRUFDdEIsY0FBMEMsRUFDekMsT0FBNEIsRUFDN0IsS0FBYTtRQUU3Qiw2RUFBNkU7UUFDN0UsNkVBQTZFO1FBQzdFLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztRQVBsQixTQUFJLEdBQUosSUFBSSxDQUFrQjtRQUN0QixtQkFBYyxHQUFkLGNBQWMsQ0FBNEI7UUFDekMsWUFBTyxHQUFQLE9BQU8sQ0FBcUI7UUFDN0IsVUFBSyxHQUFMLEtBQUssQ0FBUTtRQU03Qiw2SUFBNkk7UUFDN0ksTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRXBELElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQztRQUMvQixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUM7UUFDL0IsSUFBSSxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQztRQUN6QixJQUFJLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUM7UUFFekIsSUFBSSxLQUFLLElBQUksS0FBSyxZQUFZLFlBQVksRUFBRTtZQUMxQyxLQUFLLENBQUMsZUFBZSxHQUFHLFNBQVMsQ0FBQztTQUNuQztRQUNELElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztZQUNwQyxJQUFJO1lBQ0osY0FBYztZQUNkLE9BQU87WUFDUCxLQUFLO1NBQ04sQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELE1BQU0sQ0FBQyxVQUFVLEdBQUcsQ0FBQyxPQUFlLEVBQTRCLEVBQUU7UUFDaEUsTUFBTSxlQUFlLEdBQUcsNENBQTRDLENBQUM7UUFDckUsTUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUNsRCxJQUFJLFVBQVUsSUFBSSxVQUFVLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRTtZQUN4QyxJQUFJO2dCQUNGLE1BQU0sRUFBRSxJQUFJLEVBQUUsY0FBYyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUN6RCxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQ2QsQ0FBQztnQkFDRixPQUFPLGNBQWMsS0FBSyxPQUFPO29CQUMvQixDQUFDLENBQUMsSUFBSSxtQkFBZ0IsQ0FBQyxJQUE0QixFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUM7b0JBQ3BFLENBQUMsQ0FBQyxJQUFJLGVBQVksQ0FBQyxJQUErQixFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQzthQUN2RTtZQUFDLE9BQU8sS0FBSyxFQUFFO2dCQUNkLHFCQUFxQjthQUN0QjtTQUNGO1FBQ0QsT0FBTyxTQUFTLENBQUM7SUFDbkIsQ0FBQyxDQUFDO0lBRUYsTUFBTSxDQUFDLFNBQVMsR0FBRyxDQUFDLEtBQWMsRUFBZ0IsRUFBRTtRQUNsRCxNQUFNLFlBQVksR0FDaEIsS0FBSyxZQUFZLEtBQUs7WUFDcEIsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLElBQUksS0FBSyxLQUFLLENBQUMsT0FBTyxFQUFFO1lBQ25DLENBQUMsQ0FBQyxtREFBbUQsQ0FBQztRQUUxRCxPQUFPLElBQUksZUFBWSxDQUNyQixjQUFjLEVBQ2Q7WUFDRSxPQUFPLEVBQUUsWUFBWTtTQUN0QixFQUNELEtBQUssWUFBWSxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQzFELENBQUM7SUFDSixDQUFDLENBQUM7O0FBbkZKLG9DQW9GQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFtcGxpZnlGYXVsdCwgQW1wbGlmeVVzZXJFcnJvciB9IGZyb20gJy4nO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCBBbXBsaWZ5IGVycm9ycyBvciBmYXVsdHNcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFtcGxpZnlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcHVibGljIHNlcmlhbGl6ZWRFcnJvcj86IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IG1lc3NhZ2U6IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IHJlc29sdXRpb24/OiBzdHJpbmc7XG4gIHB1YmxpYyByZWFkb25seSBkZXRhaWxzPzogc3RyaW5nO1xuICBwdWJsaWMgcmVhZG9ubHkgbGluaz86IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IGNvZGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFlvdSBzaG91bGQgdXNlIEFtcGxpZnlVc2VyRXJyb3Igb3IgQW1wbGlmeUxpYnJhcnlGYXVsdCB0byB0aHJvdyBhbiBlcnJvci5cbiAgICogQHBhcmFtIG5hbWUgLSBhIHVzZXIgZnJpZW5kbHkgbmFtZSBmb3IgdGhlIGV4Y2VwdGlvblxuICAgKiBAcGFyYW0gY2xhc3NpZmljYXRpb24gLSBMaWJyYXJ5RmF1bHQgb3IgVXNlckVycm9yXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gZXJyb3Igc3RhY2ssIHJlc29sdXRpb24gc3RlcHMsIGRldGFpbHMsIG9yIGhlbHAgbGlua3NcbiAgICogQHBhcmFtIGNhdXNlIElmIHlvdSBhcmUgdGhyb3dpbmcgdGhpcyBleGNlcHRpb24gZnJvbSB3aXRoaW4gYSBjYXRjaCBibG9jayxcbiAgICogeW91IG11c3QgcHJvdmlkZSB0aGUgZXhjZXB0aW9uIHRoYXQgd2FzIGNhdWdodC5cbiAgICogQGV4YW1wbGVcbiAgICogdHJ5IHtcbiAgICogIC4uLlxuICAgKiB9IGNhdGNoIChlcnJvcil7XG4gICAqICAgIHRocm93IG5ldyBBbXBsaWZ5RXJyb3IoLi4uLC4uLixlcnJvcik7XG4gICAqIH1cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSBuYW1lOiBBbXBsaWZ5RXJyb3JUeXBlLFxuICAgIHB1YmxpYyByZWFkb25seSBjbGFzc2lmaWNhdGlvbjogQW1wbGlmeUVycm9yQ2xhc3NpZmljYXRpb24sXG4gICAgcHJpdmF0ZSByZWFkb25seSBvcHRpb25zOiBBbXBsaWZ5RXJyb3JPcHRpb25zLFxuICAgIHB1YmxpYyByZWFkb25seSBjYXVzZT86IEVycm9yXG4gICkge1xuICAgIC8vIElmIGFuIEFtcGxpZnlFcnJvciB3YXMgYWxyZWFkeSB0aHJvd24sIHdlIG11c3QgYWxsb3cgaXQgdG8gcmVhY2ggdGhlIHVzZXIuXG4gICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgcmVzb2x1dGlvbiBzdGVwcywgYW5kIHRoZSBvcmlnaW5hbCBlcnJvciBhcmUgYnViYmxlZCB1cC5cbiAgICBzdXBlcihvcHRpb25zLm1lc3NhZ2UsIHsgY2F1c2UgfSk7XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQtd2lraS9ibG9iL21haW4vQnJlYWtpbmctQ2hhbmdlcy5tZCNleHRlbmRpbmctYnVpbHQtaW5zLWxpa2UtZXJyb3ItYXJyYXktYW5kLW1hcC1tYXktbm8tbG9uZ2VyLXdvcmtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQW1wbGlmeUVycm9yLnByb3RvdHlwZSk7XG5cbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5kZXRhaWxzID0gb3B0aW9ucy5kZXRhaWxzO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IG9wdGlvbnMucmVzb2x1dGlvbjtcbiAgICB0aGlzLmNvZGUgPSBvcHRpb25zLmNvZGU7XG4gICAgdGhpcy5saW5rID0gb3B0aW9ucy5saW5rO1xuXG4gICAgaWYgKGNhdXNlICYmIGNhdXNlIGluc3RhbmNlb2YgQW1wbGlmeUVycm9yKSB7XG4gICAgICBjYXVzZS5zZXJpYWxpemVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuc2VyaWFsaXplZEVycm9yID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgbmFtZSxcbiAgICAgIGNsYXNzaWZpY2F0aW9uLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGNhdXNlLFxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGZyb21TdGRlcnIgPSAoX3N0ZGVycjogc3RyaW5nKTogQW1wbGlmeUVycm9yIHwgdW5kZWZpbmVkID0+IHtcbiAgICBjb25zdCBleHRyYWN0aW9uUmVnZXggPSAvW1wiJ10/c2VyaWFsaXplZEVycm9yW1wiJ10/OlsgXT9bXCInXSguKilbXCInXS87XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IF9zdGRlcnIubWF0Y2goZXh0cmFjdGlvblJlZ2V4KTtcbiAgICBpZiAoc2VyaWFsaXplZCAmJiBzZXJpYWxpemVkLmxlbmd0aCA9PSAyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IG5hbWUsIGNsYXNzaWZpY2F0aW9uLCBvcHRpb25zLCBjYXVzZSB9ID0gSlNPTi5wYXJzZShcbiAgICAgICAgICBzZXJpYWxpemVkWzFdXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBjbGFzc2lmaWNhdGlvbiA9PT0gJ0VSUk9SJ1xuICAgICAgICAgID8gbmV3IEFtcGxpZnlVc2VyRXJyb3IobmFtZSBhcyBBbXBsaWZ5VXNlckVycm9yVHlwZSwgb3B0aW9ucywgY2F1c2UpXG4gICAgICAgICAgOiBuZXcgQW1wbGlmeUZhdWx0KG5hbWUgYXMgQW1wbGlmeUxpYnJhcnlGYXVsdFR5cGUsIG9wdGlvbnMsIGNhdXNlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIGNhbm5vdCBkZXNlcmlhbGl6ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIHN0YXRpYyBmcm9tRXJyb3IgPSAoZXJyb3I6IHVua25vd24pOiBBbXBsaWZ5RXJyb3IgPT4ge1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9XG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgID8gYCR7ZXJyb3IubmFtZX06ICR7ZXJyb3IubWVzc2FnZX1gXG4gICAgICAgIDogJ0FuIHVua25vd24gZXJyb3IgaGFwcGVuZWQuIENoZWNrIGRvd25zdHJlYW0gZXJyb3InO1xuXG4gICAgcmV0dXJuIG5ldyBBbXBsaWZ5RmF1bHQoXG4gICAgICAnVW5rbm93bkZhdWx0JyxcbiAgICAgIHtcbiAgICAgICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgICAgfSxcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKVxuICAgICk7XG4gIH07XG59XG5cbi8qKlxuICogQW1wbGlmeSBleGNlcHRpb24gY2xhc3NpZmljYXRpb25zXG4gKi9cbmV4cG9ydCB0eXBlIEFtcGxpZnlFcnJvckNsYXNzaWZpY2F0aW9uID0gJ0ZBVUxUJyB8ICdFUlJPUic7XG5cbi8qKlxuICogQW1wbGlmeSBFcnJvciBvcHRpb25zIG9iamVjdFxuICovXG5leHBvcnQgdHlwZSBBbXBsaWZ5RXJyb3JPcHRpb25zID0ge1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIGRldGFpbHM/OiBzdHJpbmc7XG4gIHJlc29sdXRpb24/OiBzdHJpbmc7XG4gIGxpbms/OiBzdHJpbmc7XG5cbiAgLy8gQ2xvdWRGb3JtYXRpb24gb3IgTm9kZUpTIGVycm9yIGNvZGVzXG4gIGNvZGU/OiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIEFtcGxpZnkgZXJyb3IgdHlwZXNcbiAqL1xuZXhwb3J0IHR5cGUgQW1wbGlmeUVycm9yVHlwZSA9IEFtcGxpZnlVc2VyRXJyb3JUeXBlIHwgQW1wbGlmeUxpYnJhcnlGYXVsdFR5cGU7XG5cbi8qKlxuICogQW1wbGlmeSBlcnJvciB0eXBlc1xuICovXG5leHBvcnQgdHlwZSBBbXBsaWZ5VXNlckVycm9yVHlwZSA9XG4gIHwgJ0ludmFsaWRQYWNrYWdlSnNvbkVycm9yJ1xuICB8ICdJbnZhbGlkU2NoZW1hQXV0aEVycm9yJ1xuICB8ICdJbnZhbGlkU2NoZW1hRXJyb3InXG4gIHwgJ0V4cGlyZWRUb2tlbkVycm9yJ1xuICB8ICdDbG91ZEZvcm1hdGlvbkRlcGxveW1lbnRFcnJvcidcbiAgfCAnQ0ZOVXBkYXRlTm90U3VwcG9ydGVkRXJyb3InXG4gIHwgJ1N5bnRheEVycm9yJ1xuICB8ICdCYWNrZW5kQnVpbGRFcnJvcidcbiAgfCAnQm9vdHN0cmFwTm90RGV0ZWN0ZWRFcnJvcidcbiAgfCAnQWNjZXNzRGVuaWVkRXJyb3InXG4gIHwgJ0ZpbGVDb252ZW50aW9uRXJyb3InO1xuXG4vKipcbiAqIEFtcGxpZnkgbGlicmFyeSBmYXVsdCB0eXBlc1xuICovXG5leHBvcnQgdHlwZSBBbXBsaWZ5TGlicmFyeUZhdWx0VHlwZSA9ICdVbmtub3duRmF1bHQnO1xuIl19